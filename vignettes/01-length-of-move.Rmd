---
title: "3.1.1: Length of move"
output: 
  bookdown::pdf_document2:
    toc: no
  rmarkdown::html_vignette:
    default: yes
vignette: >
  %\VignetteIndexEntry{3.1.1: Length of move}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE}
library('Quartet', exclude = 'RobinsonFoulds')
library('TreeDist')
library('TreeDistData')
backbone <- ape::read.tree(text='(a, (b, (c, (d, (((e, f), g), (h, (i, j)))))));')
nTip <- length(backbone$tip.label)
newTrees <- structure(TreeTools::AddTipEverywhere(backbone, '11th leaf'),
                      class = 'multiPhylo')
urt <- lapply(newTrees, ape::unroot)
ordr <- order(backbone$edge[, 2])[-(nTip + 1L)]
dists <- TreeTools::EdgeDistances(backbone)[ordr, ordr]
```

```{r, echo=FALSE, fig.width=7.2, fig.asp=4/5}
BoxPlot <- function (method) {
  d <- as.matrix(TDFunctions[[method]](newTrees))
  boxplot(d ~ dists, border = TreeDistCol(method), xlab = '', ylab = '')
  mtext(tdAbbrevs[method], 2, line = 2, cex = 0.75)
  
  ranges <- vapply(sort(unique(as.integer(dists))),
                   function (i) range(d[dists == i]),
                   c('min'= 0, 'max' = 0))
  
  errors <- vapply(1:max(dists), function (i) {
    c(    tooSmall = sum(d[dists == i] <= ranges['max', i]),
       notTooSmall = sum(d[dists == i] > ranges['max', i]),
            tooBig = sum(d[dists == i - 1] >= ranges['min', i + 1]),
         notTooBig = sum(d[dists == i - 1] < ranges['min', i + 1])
      )
  }, c(tooSmall = 0, notTooSmall = 0, tooBig = 0, notTooBig = 0))
  
  nErrors <- sum(errors[c('tooSmall', 'tooBig'), ])
  
  text(4.5, 0, paste0(nErrors, '/', sum(errors), '\nmis-orderings'), pos = 3)
  nErrors
}

par(mfrow = c(4, 5), mar = c(2.5, 3.5, 0, 0.5), oma = c(1.5, 0, 0.1, 0), xpd = NA)
lapply(tdPlotSequence, BoxPlot) -> errors
mtext('Move length', 1, line = 0, cex = 0.75, outer = TRUE)
```

**Distances between eleven-leaf trees differing in the
position of a single leaf.**
_Move length_ is the number of nodes that must be traversed to travel from
the position of the moved leaf in the first tree to its position in the second.
If a pair does not have a higher distance than all pairs with a shorter move 
length, or does not have a lower distance than all pairs with a longer move
length, a mis-ordering is recorded.

## Method

I generated seventeen eleven-tip trees that differ only in the position of their
eleventh leaf.

These trees were generated by adding an eleventh leaf to each edge in an 
unrooted unrooted ten-leaf tree:
```{R backbone, echo=FALSE, fig.width=2.4, fig.asp=1, fig.align="center"}
par(mar = rep(0, 4))
plot(ape::unroot(backbone))
```

```{r, echo=FALSE, fig.width=7.2, fig.asp=3/6}
par(mfrow = c(3, 6), mar = rep(0.2, 4))
lapply(urt, plot) -> XX
```

The _move length_ between any pair of these trees is defined as the number of nodes that must be traversed to travel from the position of the eleventh leaf in one tree to its position in the second.
I define a _mis-ordering_ as a case where the distance between a pair of trees is not strictly larger than the distance between every tree pair with a shorter move length, or a case where the distance is not strictly smaller than that between every tree pair with a greater move length.

We would like a metric to display a monotonic increase, such that all tree pairs
with _n_ edges between the added leaves are further apart than any tree pair
with _n_ &minus; 1 edges between the added leaves.

```{r, output='asis', echo=FALSE}
toPrint <- t(t(errors))
dimnames(toPrint) <- list(tdMdAbbrevs[tdPlotSequence], 'Mis-orderings')

DT::datatable(toPrint, options = list(lengthChange = FALSE, paging = FALSE,
                                      searching = FALSE))
```
